<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional SVG Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            overflow: hidden;
            background: #f5f5f5;
            color: #333;
        }

        /* Toolbar Styles */
        .toolbar {
            background: #fff;
            border-bottom: 1px solid #ddd;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 16px;
            min-height: 56px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .tool-group {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #fff;
        }

        .tool-btn {
            padding: 8px 12px;
            border: none;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            color: #555;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: #f0f0f0;
            color: #333;
        }

        .tool-btn.active {
            background: #007acc;
            color: #fff;
        }

        .separator {
            width: 1px;
            height: 24px;
            background: #ddd;
            margin: 0 8px;
        }

        /* Layout */
        .main-container {
            display: grid;
            grid-template-columns: 240px 1fr 280px;
            grid-template-rows: 1fr 32px;
            grid-template-areas: 
                "left center right"
                "bottom bottom bottom";
            height: calc(100vh - 56px);
        }

        .left-panel {
            grid-area: left;
            background: #fff;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
        }

        .center-canvas {
            grid-area: center;
            background: #f9f9f9;
            position: relative;
            overflow: hidden;
        }

        .right-panel {
            grid-area: right;
            background: #fff;
            border-left: 1px solid #ddd;
            display: flex;
            flex-direction: column;
        }

        .status-bar {
            grid-area: bottom;
            background: #fff;
            border-top: 1px solid #ddd;
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-size: 12px;
            color: #666;
        }

        /* Panel Headers */
        .panel-header {
            padding: 12px 16px;
            border-bottom: 1px solid #eee;
            font-weight: 600;
            background: #f8f8f8;
        }

        .panel-content {
            padding: 16px;
            flex: 1;
            overflow-y: auto;
        }

        /* Layers Panel */
        .layers-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .layer-item {
            padding: 8px 12px;
            background: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .layer-item:hover {
            background: #f0f0f0;
        }

        .layer-item.selected {
            background: #007acc;
            color: #fff;
            border-color: #007acc;
        }

        .layer-controls {
            display: flex;
            gap: 4px;
            margin-left: auto;
        }

        .layer-btn {
            width: 20px;
            height: 20px;
            border: none;
            background: transparent;
            border-radius: 2px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .layer-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Properties Panel */
        .property-group {
            margin-bottom: 16px;
        }

        .property-group h4 {
            margin-bottom: 8px;
            font-size: 14px;
            color: #666;
        }

        .form-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .form-row label {
            min-width: 60px;
            font-size: 13px;
        }

        .form-row input, .form-row select {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }

        .form-row input[type="color"] {
            width: 40px;
            height: 28px;
            padding: 2px;
        }

        /* Canvas */
        .canvas-wrapper {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            cursor: crosshair;
        }

        .svg-canvas {
            width: 100%;
            height: 100%;
            background: #fff;
            border: 1px solid #ddd;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
        }

        /* Selection Handles */
        .selection-handle {
            fill: #fff;
            stroke: #007acc;
            stroke-width: 1;
            cursor: pointer;
        }

        .selection-handle.resize {
            cursor: nwse-resize;
        }

        .selection-handle.rotate {
            cursor: grab;
        }

        .selection-rect {
            fill: none;
            stroke: #007acc;
            stroke-width: 1;
            stroke-dasharray: 5,5;
            pointer-events: none;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: #f8f8f8;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .zoom-btn:hover {
            background: #e8e8e8;
        }

        .zoom-slider {
            width: 100%;
            margin: 4px 0;
        }

        /* Color Picker */
        .color-picker {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .color-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .color-preview {
            width: 24px;
            height: 24px;
            border: 1px solid #ddd;
            border-radius: 2px;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 200px 1fr 240px;
            }
        }

        @media (max-width: 768px) {
            .toolbar {
                flex-wrap: wrap;
                gap: 8px;
            }

            .main-container {
                grid-template-columns: 1fr;
                grid-template-areas: 
                    "center"
                    "bottom";
            }

            .left-panel, .right-panel {
                position: absolute;
                top: 56px;
                bottom: 32px;
                width: 280px;
                z-index: 100;
                transform: translateX(-100%);
                transition: transform 0.3s;
            }

            .right-panel {
                right: 0;
                transform: translateX(100%);
            }

            .panel-open.left-panel {
                transform: translateX(0);
            }

            .panel-open.right-panel {
                transform: translateX(0);
            }

            .panel-toggle {
                display: block;
            }
        }

        @media (max-width: 480px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }

        /* Hide panel toggles on desktop */
        .panel-toggle {
            display: none;
        }

        /* Navigation Help Overlay */
        .help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .help-panel {
            background: #fff;
            border-radius: 8px;
            padding: 24px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 24px rgba(0,0,0,0.3);
        }

        .help-panel h2 {
            margin-bottom: 16px;
            color: #333;
            border-bottom: 2px solid #007acc;
            padding-bottom: 8px;
        }

        .help-section {
            margin-bottom: 20px;
        }

        .help-section h3 {
            margin-bottom: 8px;
            color: #555;
            font-size: 16px;
        }

        .help-shortcuts {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .help-key {
            background: #f5f5f5;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
            font-size: 12px;
        }

        .help-desc {
            color: #666;
            font-size: 14px;
        }

        .help-close {
            position: absolute;
            top: 12px;
            right: 16px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
        }

        .help-close:hover {
            color: #333;
        }

        .navigation-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: #007acc;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
            z-index: 100;
        }

        /* Loading and Utility Classes */
        .hidden {
            display: none;
        }

        .disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .dragging {
            cursor: grabbing !important;
        }
    </style>
</head>
<body>
    <!-- Toolbar -->
    <div class="toolbar">
        <div class="tool-group">
            <button class="tool-btn" data-tool="select" title="Select (V)">
                <svg width="16" height="16" viewBox="0 0 16 16"><path d="M3 1l3 3-7 7-3 1 1-3 7-7z"/></svg>
                Select
            </button>
            <button class="tool-btn" data-tool="pen" title="Pen Tool (P)">
                <svg width="16" height="16" viewBox="0 0 16 16"><path d="M1 15l3-3 8-8-3-3-8 8 3 3zM6 6l2 2"/></svg>
                Pen
            </button>
        </div>

        <div class="tool-group">
            <button class="tool-btn" data-tool="rectangle" title="Rectangle (R)">
                <svg width="16" height="16" viewBox="0 0 16 16"><rect x="2" y="2" width="12" height="12" fill="none" stroke="currentColor"/></svg>
                Rectangle
            </button>
            <button class="tool-btn" data-tool="circle" title="Circle (C)">
                <svg width="16" height="16" viewBox="0 0 16 16"><circle cx="8" cy="8" r="6" fill="none" stroke="currentColor"/></svg>
                Circle
            </button>
            <button class="tool-btn" data-tool="ellipse" title="Ellipse (E)">
                <svg width="16" height="16" viewBox="0 0 16 16"><ellipse cx="8" cy="8" rx="7" ry="5" fill="none" stroke="currentColor"/></svg>
                Ellipse
            </button>
            <button class="tool-btn" data-tool="line" title="Line (L)">
                <svg width="16" height="16" viewBox="0 0 16 16"><line x1="2" y1="14" x2="14" y2="2" stroke="currentColor" stroke-width="2"/></svg>
                Line
            </button>
            <button class="tool-btn" data-tool="arrow" title="Arrow (A)">
                <svg width="16" height="16" viewBox="0 0 16 16"><line x1="2" y1="14" x2="14" y2="2" stroke="currentColor" stroke-width="2"/><path d="M10 2l4-4-4 4zM10 2l4-4-4 4z" fill="currentColor"/></svg>
                Arrow
            </button>
            <button class="tool-btn" data-tool="text" title="Text (T)">
                <svg width="16" height="16" viewBox="0 0 16 16"><text x="4" y="12" font-size="10" font-family="serif">T</text></svg>
                Text
            </button>
        </div>

        <div class="separator"></div>

        <div class="tool-group">
            <button class="tool-btn" id="undoBtn" title="Undo (Ctrl+Z)">
                <svg width="16" height="16" viewBox="0 0 16 16"><path d="M6 2h4v12H6l3-3-3-3z"/></svg>
                Undo
            </button>
            <button class="tool-btn" id="redoBtn" title="Redo (Ctrl+Y)">
                <svg width="16" height="16" viewBox="0 0 16 16"><path d="M10 2H6v12h4l-3-3 3-3z"/></svg>
                Redo
            </button>
        </div>

        <div class="separator"></div>

        <div class="tool-group">
            <button class="tool-btn" id="importSvgBtn" title="Import SVG">
                <svg width="16" height="16" viewBox="0 0 16 16"><path d="M8 15l-4-4h3V5h2v6h3zM4 3V1h8v2H4z"/></svg>
                Import SVG
            </button>
            <button class="tool-btn" id="exportSvgBtn" title="Export SVG">
                <svg width="16" height="16" viewBox="0 0 16 16"><path d="M8 1l4 4h-3v6h-2V5H4zM4 13v2h8v-2H4z"/></svg>
                Export SVG
            </button>
            <button class="tool-btn" id="exportPngBtn" title="Export PNG">
                <svg width="16" height="16" viewBox="0 0 16 16"><rect x="2" y="2" width="12" height="12" fill="none" stroke="currentColor"/><rect x="4" y="6" width="8" height="6" fill="currentColor"/></svg>
                Export PNG
            </button>
        </div>

        <div class="separator"></div>

        <div class="tool-group">
            <button class="tool-btn" id="toggleGridBtn" title="Toggle Grid (G)">
                <svg width="16" height="16" viewBox="0 0 16 16"><path d="M1 0h1v16H1zM0 1h16v1H0zM8 0h1v16H8zM0 8h16v1H0zM3 0h1v16H3zM0 3h16v1H0z"/></svg>
                Grid
            </button>
            <button class="tool-btn" id="snapToGridBtn" title="Snap to Grid (S)">
                <svg width="16" height="16" viewBox="0 0 16 16"><rect x="3" y="3" width="10" height="10" fill="none" stroke="currentColor"/><path d="M8 3v10M3 8h10" stroke="currentColor"/></svg>
                Snap
            </button>
        </div>

        <button class="panel-toggle tool-btn" data-panel="left" title="Toggle Left Panel">
            <svg width="16" height="16" viewBox="0 0 16 16"><path d="M1 3h14v10H1zM4 6h8v4H4z"/></svg>
        </button>

        <button class="panel-toggle tool-btn" data-panel="right" title="Toggle Right Panel">
            <svg width="16" height="16" viewBox="0 0 16 16"><path d="M1 3h14v10H1zM4 6h8v4H4z"/></svg>
        </button>

        <div class="separator"></div>

        <button class="tool-btn" id="helpBtn" title="Navigation Help (?)">
            <svg width="16" height="16" viewBox="0 0 16 16"><circle cx="8" cy="8" r="6" fill="none" stroke="currentColor" stroke-width="2"/><path d="M6 6c0-1.1.9-2 2-2s2 .9 2 2c0 1-1 1.5-2 2" stroke="currentColor" stroke-width="1.5" fill="none"/><circle cx="8" cy="12" r="1" fill="currentColor"/></svg>
            Help
        </button>
    </div>

    <!-- Hidden file input for SVG import -->
    <input type="file" id="svgFileInput" accept=".svg" style="display: none;">

    <!-- Main Container -->
    <div class="main-container">
        <!-- Left Panel -->
        <div class="left-panel" id="leftPanel">
            <div class="panel-header">Layers</div>
            <div class="panel-content">
                <div class="form-row">
                    <button class="tool-btn" id="addLayerBtn" style="width: 100%;">
                        <svg width="16" height="16" viewBox="0 0 16 16"><path d="M8 1v14M1 8h14" stroke="currentColor" stroke-width="2"/></svg>
                        Add Layer
                    </button>
                </div>
                <div class="layers-list" id="layersList">
                    <!-- Layers will be populated here -->
                </div>
            </div>

            <div class="panel-header">Properties</div>
            <div class="panel-content" id="propertiesPanel">
                <div class="property-group">
                    <h4>Position</h4>
                    <div class="form-row">
                        <label>X:</label>
                        <input type="number" id="posX" step="1">
                    </div>
                    <div class="form-row">
                        <label>Y:</label>
                        <input type="number" id="posY" step="1">
                    </div>
                </div>

                <div class="property-group">
                    <h4>Size</h4>
                    <div class="form-row">
                        <label>Width:</label>
                        <input type="number" id="width" step="1">
                    </div>
                    <div class="form-row">
                        <label>Height:</label>
                        <input type="number" id="height" step="1">
                    </div>
                </div>

                <div class="property-group">
                    <h4>Transform</h4>
                    <div class="form-row">
                        <label>Rotate:</label>
                        <input type="number" id="rotation" step="1">
                    </div>
                    <div class="form-row">
                        <label>Scale:</label>
                        <input type="number" id="scale" step="0.1" min="0.1">
                    </div>
                </div>
            </div>
        </div>

        <!-- Center Canvas -->
        <div class="center-canvas">
            <div class="canvas-wrapper" id="canvasWrapper">
                <svg class="svg-canvas" id="svgCanvas" xmlns="http://www.w3.org/2000/svg">
                    <!-- Grid -->
                    <defs>
                        <pattern id="gridPattern" width="20" height="20" patternUnits="userSpaceOnUse">
                            <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#ddd" stroke-width="1"/>
                        </pattern>
                    </defs>
                    <rect id="gridRect" width="100%" height="100%" fill="url(#gridPattern)" opacity="0.3" style="display: none;"/>
                    
                    <!-- Layers will be added here -->
                    <g id="drawingLayers"></g>
                    
                    <!-- Selection overlay -->
                    <g id="selectionOverlay"></g>
                </svg>

                <!-- Zoom Controls -->
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoomInBtn" title="Zoom In (+)">+</button>
                    <input type="range" class="zoom-slider" id="zoomSlider" min="0.1" max="5" step="0.1" value="1">
                    <button class="zoom-btn" id="zoomOutBtn" title="Zoom Out (-)">‚àí</button>
                    <button class="zoom-btn" id="zoomFitBtn" title="Fit to Screen">‚§¢</button>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel" id="rightPanel">
            <div class="panel-header">Styling</div>
            <div class="panel-content">
                <div class="property-group">
                    <h4>Fill</h4>
                    <div class="form-row">
                        <label>Color:</label>
                        <input type="color" id="fillColor" value="#ffffff">
                        <div class="color-preview" id="fillPreview"></div>
                    </div>
                    <div class="form-row">
                        <label>Opacity:</label>
                        <input type="range" id="fillOpacity" min="0" max="1" step="0.1" value="1">
                        <span id="fillOpacityValue">100%</span>
                    </div>
                </div>

                <div class="property-group">
                    <h4>Stroke</h4>
                    <div class="form-row">
                        <label>Color:</label>
                        <input type="color" id="strokeColor" value="#000000">
                        <div class="color-preview" id="strokePreview"></div>
                    </div>
                    <div class="form-row">
                        <label>Width:</label>
                        <input type="number" id="strokeWidth" min="0" max="50" step="0.5" value="1">
                    </div>
                    <div class="form-row">
                        <label>Opacity:</label>
                        <input type="range" id="strokeOpacity" min="0" max="1" step="0.1" value="1">
                        <span id="strokeOpacityValue">100%</span>
                    </div>
                </div>

                <div class="property-group">
                    <h4>Text Properties</h4>
                    <div class="form-row">
                        <label>Font:</label>
                        <select id="fontFamily">
                            <option value="Arial, sans-serif">Arial</option>
                            <option value="Helvetica, sans-serif">Helvetica</option>
                            <option value="Times, serif">Times</option>
                            <option value="Georgia, serif">Georgia</option>
                            <option value="Courier, monospace">Courier</option>
                            <option value="Verdana, sans-serif">Verdana</option>
                        </select>
                    </div>
                    <div class="form-row">
                        <label>Size:</label>
                        <input type="number" id="fontSize" min="6" max="200" step="1" value="16">
                    </div>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <span id="statusText">Ready</span>
            <span style="margin-left: auto;">
                Zoom: <span id="zoomLevel">100%</span> | 
                Position: <span id="cursorPos">0, 0</span> |
                <span id="navigationHint">Hold Spacebar to pan ‚Ä¢ ? for help</span>
            </span>
        </div>
    </div>

    <!-- Navigation Help Overlay -->
    <div class="help-overlay" id="helpOverlay">
        <div class="help-panel">
            <button class="help-close" id="helpClose">&times;</button>
            <h2>SVG Editor - Navigation Guide</h2>
            
            <div class="help-section">
                <h3>üñ±Ô∏è Canvas Navigation</h3>
                <div class="help-shortcuts">
                    <span class="help-key">Spacebar + Drag</span>
                    <span class="help-desc">Pan around the canvas (most common)</span>
                    <span class="help-key">Middle Mouse Drag</span>
                    <span class="help-desc">Alternative panning method</span>
                    <span class="help-key">Right Click + Drag</span>
                    <span class="help-desc">Another panning option</span>
                    <span class="help-key">Arrow Keys</span>
                    <span class="help-desc">Precise directional movement</span>
                </div>
            </div>

            <div class="help-section">
                <h3>üîç Zoom Controls</h3>
                <div class="help-shortcuts">
                    <span class="help-key">Ctrl + Mouse Wheel</span>
                    <span class="help-desc">Zoom toward mouse cursor</span>
                    <span class="help-key">Shift + Mouse Wheel</span>
                    <span class="help-desc">Pan horizontally/vertically</span>
                    <span class="help-key">+ / -</span>
                    <span class="help-desc">Zoom in/out</span>
                    <span class="help-key">0</span>
                    <span class="help-desc">Reset zoom to 100%</span>
                </div>
            </div>

            <div class="help-section">
                <h3>‚å®Ô∏è Tool Shortcuts</h3>
                <div class="help-shortcuts">
                    <span class="help-key">V</span>
                    <span class="help-desc">Select tool</span>
                    <span class="help-key">R</span>
                    <span class="help-desc">Rectangle tool</span>
                    <span class="help-key">C</span>
                    <span class="help-desc">Circle tool</span>
                    <span class="help-key">P</span>
                    <span class="help-desc">Pen tool</span>
                    <span class="help-key">T</span>
                    <span class="help-desc">Text tool</span>
                    <span class="help-key">Escape</span>
                    <span class="help-desc">Clear selection</span>
                </div>
            </div>

            <div class="help-section">
                <h3>üìù General Shortcuts</h3>
                <div class="help-shortcuts">
                    <span class="help-key">Ctrl + Z</span>
                    <span class="help-desc">Undo</span>
                    <span class="help-key">Ctrl + Y</span>
                    <span class="help-desc">Redo</span>
                    <span class="help-key">Ctrl + C</span>
                    <span class="help-desc">Copy selected</span>
                    <span class="help-key">Ctrl + V</span>
                    <span class="help-desc">Paste</span>
                    <span class="help-key">Delete</span>
                    <span class="help-desc">Delete selected</span>
                </div>
            </div>

            <div class="help-section">
                <h3>üí° Pro Tips</h3>
                <ul style="margin-left: 20px; color: #666;">
                    <li>Import an SVG file, zoom in, then use Spacebar+drag to navigate</li>
                    <li>Use arrow keys for precise positioning of elements</li>
                    <li>Ctrl+wheel zoom keeps your mouse cursor as the zoom center</li>
                    <li>Hold Ctrl/Cmd while clicking to select multiple elements</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Navigation Indicator -->
    <div class="navigation-indicator" id="navigationIndicator">
        Panning Mode - Drag to navigate
    </div>

    <script>
        class SVGEditor {
            constructor() {
                this.currentTool = 'select';
                this.isDrawing = false;
                this.startX = 0;
                this.startY = 0;
                this.currentPath = null;
                this.tempElement = null;
                this.selectedElements = [];
                this.dragOffset = { x: 0, y: 0 };
                this.isDragging = false;
                this.history = [];
                this.historyIndex = -1;
                this.maxHistory = 20;
                this.zoom = 1;
                this.panX = 0;
                this.panY = 0;
                this.showGrid = false;
                this.snapToGrid = false;
                this.gridSize = 20;
                this.layers = [];
                this.currentLayer = 0;
                this.isPanning = false;
                this.panStart = { x: 0, y: 0 };
                this.spacebarPressed = false;
                
                this.init();
            }

            init() {
                this.initCanvas();
                this.initTools();
                this.initPanels();
                this.initZoomControls();
                this.initEventListeners();
                this.initKeyboardShortcuts();
                this.addLayer();
                this.updateUI();
                this.saveState();
            }

            initCanvas() {
                this.canvas = document.getElementById('svgCanvas');
                this.canvasWrapper = document.getElementById('canvasWrapper');
                this.drawingLayers = document.getElementById('drawingLayers');
                this.selectionOverlay = document.getElementById('selectionOverlay');
                
                this.updateCanvasSize();
                window.addEventListener('resize', () => this.updateCanvasSize());
            }

            updateCanvasSize() {
                const rect = this.canvasWrapper.getBoundingClientRect();
                this.canvas.setAttribute('width', rect.width);
                this.canvas.setAttribute('height', rect.height);
                this.canvas.setAttribute('viewBox', `${this.panX} ${this.panY} ${rect.width / this.zoom} ${rect.height / this.zoom}`);
            }

            initTools() {
                const toolButtons = document.querySelectorAll('.tool-btn[data-tool]');
                toolButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.setTool(btn.dataset.tool);
                    });
                });
                this.setTool('select');
            }

            setTool(tool) {
                this.currentTool = tool;
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
                this.canvas.style.cursor = this.getCursorForTool(tool);
                this.updateStatus(`Tool: ${tool.charAt(0).toUpperCase() + tool.slice(1)}`);
            }

            getCursorForTool(tool) {
                const cursors = {
                    select: 'default',
                    pen: 'crosshair',
                    rectangle: 'crosshair',
                    circle: 'crosshair',
                    ellipse: 'crosshair',
                    line: 'crosshair',
                    arrow: 'crosshair',
                    text: 'text'
                };
                return cursors[tool] || 'default';
            }

            initPanels() {
                // Layer management
                document.getElementById('addLayerBtn').addEventListener('click', () => this.addLayer());
                
                // Panel toggles
                document.querySelectorAll('.panel-toggle').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const panel = btn.dataset.panel;
                        document.querySelector(`.${panel}-panel`).classList.toggle('panel-open');
                    });
                });
            }

            initZoomControls() {
                document.getElementById('zoomInBtn').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoomOutBtn').addEventListener('click', () => this.zoomOut());
                document.getElementById('zoomFitBtn').addEventListener('click', () => this.zoomToFit());
                
                const slider = document.getElementById('zoomSlider');
                slider.addEventListener('input', (e) => {
                    this.setZoom(parseFloat(e.target.value));
                });
            }

            zoomIn() {
                this.setZoom(Math.min(this.zoom * 1.2, 5));
            }

            zoomOut() {
                this.setZoom(Math.max(this.zoom / 1.2, 0.1));
            }

            setZoom(scale) {
                this.zoom = scale;
                document.getElementById('zoomSlider').value = scale;
                document.getElementById('zoomLevel').textContent = Math.round(scale * 100) + '%';
                this.updateCanvasSize();
            }

            zoomToFit() {
                // Calculate bounding box of all elements
                const elements = this.drawingLayers.querySelectorAll('*:not(g)');
                if (elements.length === 0) return;

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                elements.forEach(el => {
                    const bbox = el.getBBox();
                    minX = Math.min(minX, bbox.x);
                    minY = Math.min(minY, bbox.y);
                    maxX = Math.max(maxX, bbox.x + bbox.width);
                    maxY = Math.max(maxY, bbox.y + bbox.height);
                });

                const width = maxX - minX;
                const height = maxY - minY;
                const padding = 50;
                
                const rect = this.canvasWrapper.getBoundingClientRect();
                const scaleX = (rect.width - padding * 2) / width;
                const scaleY = (rect.height - padding * 2) / height;
                
                this.setZoom(Math.min(scaleX, scaleY, 2));
                this.panX = minX - padding / this.zoom;
                this.panY = minY - padding / this.zoom;
                this.updateCanvasSize();
            }

            initEventListeners() {
                // Canvas events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                
                // Prevent context menu on right-click to enable right-click panning
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Mouse wheel for panning (with Shift) or zooming (default)
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                
                // Cursor position tracking
                this.canvas.addEventListener('mousemove', (e) => this.updateCursorPosition(e));

                // Import/Export buttons
                document.getElementById('importSvgBtn').addEventListener('click', () => this.openImportDialog());
                document.getElementById('svgFileInput').addEventListener('change', (e) => this.handleSvgImport(e));
                document.getElementById('exportSvgBtn').addEventListener('click', () => this.exportSVG());
                document.getElementById('exportPngBtn').addEventListener('click', () => this.exportPNG());
                
                // Grid controls
                document.getElementById('toggleGridBtn').addEventListener('click', () => this.toggleGrid());
                document.getElementById('snapToGridBtn').addEventListener('click', () => this.toggleSnapToGrid());

                // Help system
                document.getElementById('helpBtn').addEventListener('click', () => this.showHelp());
                document.getElementById('helpClose').addEventListener('click', () => this.hideHelp());
                document.getElementById('helpOverlay').addEventListener('click', (e) => {
                    if (e.target === document.getElementById('helpOverlay')) {
                        this.hideHelp();
                    }
                });

                // Properties panel
                this.initPropertiesPanel();

                // Touch support
                this.initTouchEvents();
            }

            initTouchEvents() {
                let touchStartTime = 0;
                
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touchStartTime = Date.now();
                    const touch = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    const x = (touch.clientX - rect.left) / this.zoom + this.panX;
                    const y = (touch.clientY - rect.top) / this.zoom + this.panY;
                    
                    if (e.touches.length === 1) {
                        if (Date.now() - touchStartTime < 500) {
                            // Short tap - regular click
                            this.handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY, preventDefault: () => {} });
                        } else {
                            // Long press - start panning
                            this.startPan(touch.clientX, touch.clientY);
                        }
                    } else if (e.touches.length === 2) {
                        // Two finger touch - zoom
                        this.startTouchZoom(e);
                    }
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (e.touches.length === 1 && this.isPanning) {
                        this.updatePan(e.touches[0].clientX, e.touches[0].clientY);
                    } else if (e.touches.length === 2) {
                        this.updateTouchZoom(e);
                    }
                });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (e.touches.length === 0) {
                        this.endPan();
                        this.endTouchZoom();
                    }
                });
            }

            handleMouseDown(e) {
                e.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / this.zoom + this.panX;
                const y = (e.clientY - rect.top) / this.zoom + this.panY;

                this.startX = x;
                this.startY = y;

                // Middle mouse button (1) or spacebar+left click for panning
                if (e.button === 1 || (e.button === 0 && this.spacebarPressed)) {
                    this.startPan(e.clientX, e.clientY);
                    return;
                }

                // Right mouse button - prevent context menu and optionally pan
                if (e.button === 2) {
                    this.startPan(e.clientX, e.clientY);
                    return;
                }

                // Left mouse button (0) - normal tool interaction
                if (e.button === 0 && !this.spacebarPressed) {
                    if (this.currentTool === 'select') {
                        this.handleSelectionMouseDown(e, x, y);
                    } else if (this.currentTool === 'pen') {
                        this.handlePenMouseDown(x, y);
                    } else {
                        this.handleShapeMouseDown(x, y);
                    }
                }
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / this.zoom + this.panX;
                const y = (e.clientY - rect.top) / this.zoom + this.panY;

                // Handle panning if active
                if (this.isPanning) {
                    this.updatePan(e.clientX, e.clientY);
                    return;
                }

                if (this.isDragging) {
                    this.handleDrag(x, y);
                } else if (this.isDrawing) {
                    if (this.currentTool === 'pen') {
                        this.handlePenMouseMove(x, y);
                    } else {
                        this.handleShapeMouseMove(x, y);
                    }
                }
            }

            handleMouseUp(e) {
                if (this.isPanning) {
                    this.endPan();
                } else if (this.isDrawing) {
                    this.finishDrawing();
                } else if (this.isDragging) {
                    this.finishDragging();
                }
            }

            handleCanvasClick(e) {
                if (this.currentTool === 'text') {
                    this.addTextElement(e);
                }
            }

            handleWheel(e) {
                e.preventDefault();
                
                if (e.shiftKey) {
                    // Shift+wheel for panning
                    const panSpeed = 30;
                    this.panX += e.deltaY > 0 ? panSpeed : -panSpeed;
                    this.panY += e.deltaX > 0 ? panSpeed : -panSpeed;
                    this.updateCanvasSize();
                } else if (e.ctrlKey || e.metaKey) {
                    // Ctrl+wheel for zooming
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = Math.max(0.1, Math.min(5, this.zoom * zoomFactor));
                    
                    // Zoom towards mouse position
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = (e.clientX - rect.left) / this.zoom + this.panX;
                    const mouseY = (e.clientY - rect.top) / this.zoom + this.panY;
                    
                    const zoomRatio = newZoom / this.zoom;
                    this.panX = mouseX - (mouseX - this.panX) * zoomRatio;
                    this.panY = mouseY - (mouseY - this.panY) * zoomRatio;
                    
                    this.setZoom(newZoom);
                }
            }

            handleSelectionMouseDown(e, x, y) {
                const target = e.target;
                
                // Check if clicking on a handle
                if (target.classList.contains('selection-handle')) {
                    this.startTransform(target.dataset.handle, x, y);
                    return;
                }

                // Check if clicking on a selected element
                if (this.selectedElements.includes(target)) {
                    this.startDragging(x, y);
                    return;
                }

                // Check if clicking on any element
                if (target !== this.canvas && target !== this.drawingLayers) {
                    if (e.ctrlKey || e.metaKey) {
                        this.toggleSelection(target);
                    } else {
                        this.selectElement(target);
                    }
                } else {
                    // Clicking on empty space - clear selection
                    this.clearSelection();
                }
            }

            selectElement(element) {
                this.clearSelection();
                if (element && element !== this.canvas) {
                    this.selectedElements = [element];
                    this.showSelection();
                    this.updatePropertiesPanel();
                }
            }

            toggleSelection(element) {
                const index = this.selectedElements.indexOf(element);
                if (index > -1) {
                    this.selectedElements.splice(index, 1);
                } else {
                    this.selectedElements.push(element);
                }
                this.showSelection();
                this.updatePropertiesPanel();
            }

            clearSelection() {
                this.selectedElements = [];
                this.hideSelection();
            }

            showSelection() {
                this.hideSelection();
                
                this.selectedElements.forEach(element => {
                    const bbox = element.getBBox();
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', bbox.x);
                    rect.setAttribute('y', bbox.y);
                    rect.setAttribute('width', bbox.width);
                    rect.setAttribute('height', bbox.height);
                    rect.setAttribute('class', 'selection-rect');
                    this.selectionOverlay.appendChild(rect);

                    // Add resize handles
                    const handles = [
                        { x: bbox.x, y: bbox.y, cursor: 'nwse-resize', handle: 'nw' },
                        { x: bbox.x + bbox.width, y: bbox.y, cursor: 'nesw-resize', handle: 'ne' },
                        { x: bbox.x, y: bbox.y + bbox.height, cursor: 'nesw-resize', handle: 'sw' },
                        { x: bbox.x + bbox.width, y: bbox.y + bbox.height, cursor: 'nwse-resize', handle: 'se' }
                    ];

                    handles.forEach(({ x, y, cursor, handle }) => {
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', x);
                        circle.setAttribute('cy', y);
                        circle.setAttribute('r', 6);
                        circle.setAttribute('class', 'selection-handle resize');
                        circle.dataset.handle = handle;
                        this.selectionOverlay.appendChild(circle);
                    });

                    // Add rotate handle
                    const rotateHandle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    rotateHandle.setAttribute('cx', bbox.x + bbox.width / 2);
                    rotateHandle.setAttribute('cy', bbox.y - 20);
                    rotateHandle.setAttribute('r', 6);
                    rotateHandle.setAttribute('class', 'selection-handle rotate');
                    rotateHandle.dataset.handle = 'rotate';
                    this.selectionOverlay.appendChild(rotateHandle);
                });
            }

            hideSelection() {
                while (this.selectionOverlay.firstChild) {
                    this.selectionOverlay.removeChild(this.selectionOverlay.firstChild);
                }
            }

            startDragging(x, y) {
                this.isDragging = true;
                this.dragOffset.x = x - parseFloat(this.selectedElements[0].getAttribute('x') || 0);
                this.dragOffset.y = y - parseFloat(this.selectedElements[0].getAttribute('y') || 0);
                this.canvas.classList.add('dragging');
            }

            handleDrag(x, y) {
                const newX = x - this.dragOffset.x;
                const newY = y - this.dragOffset.y;
                
                if (this.snapToGrid) {
                    const snappedX = Math.round(newX / this.gridSize) * this.gridSize;
                    const snappedY = Math.round(newY / this.gridSize) * this.gridSize;
                    
                    this.selectedElements.forEach(element => {
                        element.setAttribute('x', snappedX);
                        element.setAttribute('y', snappedY);
                    });
                } else {
                    this.selectedElements.forEach(element => {
                        element.setAttribute('x', newX);
                        element.setAttribute('y', newY);
                    });
                }
                
                this.showSelection();
            }

            finishDragging() {
                this.isDragging = false;
                this.canvas.classList.remove('dragging');
                this.saveState();
            }

            startTransform(handle, x, y) {
                this.isTransforming = true;
                this.transformHandle = handle;
                this.transformStartX = x;
                this.transformStartY = y;
                this.transformElements = [...this.selectedElements];
            }

            handleTransform(x, y) {
                const dx = x - this.transformStartX;
                const dy = y - this.transformStartY;
                
                this.transformElements.forEach(element => {
                    switch (this.transformHandle) {
                        case 'nw':
                            element.setAttribute('x', parseFloat(element.getAttribute('x')) + dx);
                            element.setAttribute('y', parseFloat(element.getAttribute('y')) + dy);
                            element.setAttribute('width', parseFloat(element.getAttribute('width')) - dx);
                            element.setAttribute('height', parseFloat(element.getAttribute('height')) - dy);
                            break;
                        case 'ne':
                            element.setAttribute('y', parseFloat(element.getAttribute('y')) + dy);
                            element.setAttribute('width', parseFloat(element.getAttribute('width')) + dx);
                            element.setAttribute('height', parseFloat(element.getAttribute('height')) - dy);
                            break;
                        case 'sw':
                            element.setAttribute('x', parseFloat(element.getAttribute('x')) + dx);
                            element.setAttribute('width', parseFloat(element.getAttribute('width')) - dx);
                            element.setAttribute('height', parseFloat(element.getAttribute('height')) + dy);
                            break;
                        case 'se':
                            element.setAttribute('width', parseFloat(element.getAttribute('width')) + dx);
                            element.setAttribute('height', parseFloat(element.getAttribute('height')) + dy);
                            break;
                        case 'rotate':
                            const centerX = parseFloat(element.getAttribute('x')) + parseFloat(element.getAttribute('width')) / 2;
                            const centerY = parseFloat(element.getAttribute('y')) + parseFloat(element.getAttribute('height')) / 2;
                            const angle = Math.atan2(y - centerY, x - centerX) * 180 / Math.PI + 90;
                            element.dataset.rotation = angle;
                            break;
                    }
                });
                
                this.showSelection();
            }

            finishTransform() {
                this.isTransforming = false;
                this.saveState();
            }

            handlePenMouseDown(x, y) {
                this.isDrawing = true;
                this.currentPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                this.currentPath.setAttribute('d', `M ${x} ${y}`);
                this.currentPath.setAttribute('fill', 'none');
                this.currentPath.setAttribute('stroke', '#000');
                this.currentPath.setAttribute('stroke-width', '2');
                this.drawingLayers.appendChild(this.currentPath);
            }

            handlePenMouseMove(x, y) {
                if (!this.currentPath) return;
                
                const currentD = this.currentPath.getAttribute('d');
                this.currentPath.setAttribute('d', `${currentD} L ${x} ${y}`);
            }

            handleShapeMouseDown(x, y) {
                this.isDrawing = true;
                this.tempElement = this.createElement(this.currentTool, x, y);
                this.drawingLayers.appendChild(this.tempElement);
            }

            handleShapeMouseMove(x, y) {
                if (!this.tempElement) return;
                
                const width = x - this.startX;
                const height = y - this.startY;
                
                if (this.currentTool === 'rectangle') {
                    this.tempElement.setAttribute('x', Math.min(this.startX, x));
                    this.tempElement.setAttribute('y', Math.min(this.startY, y));
                    this.tempElement.setAttribute('width', Math.abs(width));
                    this.tempElement.setAttribute('height', Math.abs(height));
                } else if (this.currentTool === 'circle') {
                    const radius = Math.sqrt(width * width + height * height);
                    this.tempElement.setAttribute('cx', this.startX);
                    this.tempElement.setAttribute('cy', this.startY);
                    this.tempElement.setAttribute('r', radius / 2);
                } else if (this.currentTool === 'ellipse') {
                    this.tempElement.setAttribute('cx', this.startX);
                    this.tempElement.setAttribute('cy', this.startY);
                    this.tempElement.setAttribute('rx', Math.abs(width) / 2);
                    this.tempElement.setAttribute('ry', Math.abs(height) / 2);
                } else if (this.currentTool === 'line' || this.currentTool === 'arrow') {
                    this.tempElement.setAttribute('x1', this.startX);
                    this.tempElement.setAttribute('y1', this.startY);
                    this.tempElement.setAttribute('x2', x);
                    this.tempElement.setAttribute('y2', y);
                    
                    if (this.currentTool === 'arrow') {
                        this.updateArrowHead(this.tempElement, this.startX, this.startY, x, y);
                    }
                }
            }

            finishDrawing() {
                this.isDrawing = false;
                if (this.tempElement) {
                    this.selectElement(this.tempElement);
                    this.tempElement = null;
                    this.saveState();
                }
                if (this.currentPath) {
                    this.selectElement(this.currentPath);
                    this.currentPath = null;
                    this.saveState();
                }
            }

            createElement(tool, x, y) {
                const namespace = 'http://www.w3.org/2000/svg';
                
                switch (tool) {
                    case 'rectangle':
                        const rect = document.createElementNS(namespace, 'rect');
                        rect.setAttribute('x', x);
                        rect.setAttribute('y', y);
                        rect.setAttribute('width', 10);
                        rect.setAttribute('height', 10);
                        rect.setAttribute('fill', '#ffffff');
                        rect.setAttribute('stroke', '#000000');
                        rect.setAttribute('stroke-width', '1');
                        rect.classList.add('svg-element');
                        return rect;
                        
                    case 'circle':
                        const circle = document.createElementNS(namespace, 'circle');
                        circle.setAttribute('cx', x);
                        circle.setAttribute('cy', y);
                        circle.setAttribute('r', 5);
                        circle.setAttribute('fill', '#ffffff');
                        circle.setAttribute('stroke', '#000000');
                        circle.setAttribute('stroke-width', '1');
                        circle.classList.add('svg-element');
                        return circle;
                        
                    case 'ellipse':
                        const ellipse = document.createElementNS(namespace, 'ellipse');
                        ellipse.setAttribute('cx', x);
                        ellipse.setAttribute('cy', y);
                        ellipse.setAttribute('rx', 5);
                        ellipse.setAttribute('ry', 3);
                        ellipse.setAttribute('fill', '#ffffff');
                        ellipse.setAttribute('stroke', '#000000');
                        ellipse.setAttribute('stroke-width', '1');
                        ellipse.classList.add('svg-element');
                        return ellipse;
                        
                    case 'line':
                        const line = document.createElementNS(namespace, 'line');
                        line.setAttribute('x1', x);
                        line.setAttribute('y1', y);
                        line.setAttribute('x2', x);
                        line.setAttribute('y2', y);
                        line.setAttribute('stroke', '#000000');
                        line.setAttribute('stroke-width', '2');
                        line.classList.add('svg-element');
                        return line;
                        
                    case 'arrow':
                        const arrow = document.createElementNS(namespace, 'line');
                        arrow.setAttribute('x1', x);
                        arrow.setAttribute('y1', y);
                        arrow.setAttribute('x2', x);
                        arrow.setAttribute('y2', y);
                        arrow.setAttribute('stroke', '#000000');
                        arrow.setAttribute('stroke-width', '2');
                        arrow.classList.add('svg-element');
                        return arrow;
                        
                    default:
                        return null;
                }
            }

            updateArrowHead(line, x1, y1, x2, y2) {
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const headLength = 15;
                
                const hx1 = x2 - headLength * Math.cos(angle - Math.PI / 6);
                const hy1 = y2 - headLength * Math.sin(angle - Math.PI / 6);
                const hx2 = x2 - headLength * Math.cos(angle + Math.PI / 6);
                const hy2 = y2 - headLength * Math.sin(angle + Math.PI / 6);
                
                // Create arrow head
                let arrowHead = line.nextElementSibling;
                if (!arrowHead || !arrowHead.classList.contains('arrow-head')) {
                    arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    arrowHead.classList.add('arrow-head');
                    line.parentNode.insertBefore(arrowHead, line.nextSibling);
                }
                
                arrowHead.setAttribute('d', `M ${hx1} ${hy1} L ${x2} ${y2} L ${hx2} ${hy2}`);
                arrowHead.setAttribute('stroke', line.getAttribute('stroke'));
                arrowHead.setAttribute('stroke-width', line.getAttribute('stroke-width'));
                arrowHead.setAttribute('fill', line.getAttribute('stroke'));
            }

            addTextElement(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / this.zoom + this.panX;
                const y = (e.clientY - rect.top) / this.zoom + this.panY;
                
                const text = prompt('Enter text:');
                if (text) {
                    const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    textElement.setAttribute('x', x);
                    textElement.setAttribute('y', y);
                    textElement.setAttribute('fill', '#000000');
                    textElement.setAttribute('font-size', '16');
                    textElement.setAttribute('font-family', 'Arial, sans-serif');
                    textElement.textContent = text;
                    textElement.classList.add('svg-element');
                    
                    this.drawingLayers.appendChild(textElement);
                    this.selectElement(textElement);
                    this.saveState();
                }
            }

            initPropertiesPanel() {
                // Position properties
                document.getElementById('posX').addEventListener('input', (e) => {
                    this.selectedElements.forEach(el => {
                        if (el.tagName === 'text') {
                            el.setAttribute('x', parseFloat(e.target.value));
                        } else {
                            el.setAttribute('x', parseFloat(e.target.value));
                        }
                    });
                    this.showSelection();
                    this.saveState();
                });

                document.getElementById('posY').addEventListener('input', (e) => {
                    this.selectedElements.forEach(el => {
                        if (el.tagName === 'text') {
                            el.setAttribute('y', parseFloat(e.target.value));
                        } else {
                            el.setAttribute('y', parseFloat(e.target.value));
                        }
                    });
                    this.showSelection();
                    this.saveState();
                });

                // Size properties
                document.getElementById('width').addEventListener('input', (e) => {
                    this.selectedElements.forEach(el => {
                        if (el.tagName === 'rect' || el.tagName === 'ellipse') {
                            el.setAttribute('width', parseFloat(e.target.value));
                        } else if (el.tagName === 'circle') {
                            el.setAttribute('r', parseFloat(e.target.value) / 2);
                        }
                    });
                    this.showSelection();
                    this.saveState();
                });

                document.getElementById('height').addEventListener('input', (e) => {
                    this.selectedElements.forEach(el => {
                        if (el.tagName === 'rect' || el.tagName === 'ellipse') {
                            el.setAttribute('height', parseFloat(e.target.value));
                        } else if (el.tagName === 'circle') {
                            el.setAttribute('r', parseFloat(e.target.value) / 2);
                        }
                    });
                    this.showSelection();
                    this.saveState();
                });

                // Fill properties
                document.getElementById('fillColor').addEventListener('input', (e) => {
                    this.selectedElements.forEach(el => {
                        if (el.tagName !== 'line' && el.tagName !== 'path') {
                            el.setAttribute('fill', e.target.value);
                        }
                    });
                    this.updateColorPreviews();
                    this.saveState();
                });

                document.getElementById('fillOpacity').addEventListener('input', (e) => {
                    this.selectedElements.forEach(el => {
                        if (el.tagName !== 'line' && el.tagName !== 'path') {
                            el.setAttribute('fill-opacity', e.target.value);
                        }
                    });
                    document.getElementById('fillOpacityValue').textContent = Math.round(e.target.value * 100) + '%';
                    this.saveState();
                });

                // Stroke properties
                document.getElementById('strokeColor').addEventListener('input', (e) => {
                    this.selectedElements.forEach(el => {
                        el.setAttribute('stroke', e.target.value);
                    });
                    this.updateColorPreviews();
                    this.saveState();
                });

                document.getElementById('strokeWidth').addEventListener('input', (e) => {
                    this.selectedElements.forEach(el => {
                        el.setAttribute('stroke-width', e.target.value);
                    });
                    this.saveState();
                });

                document.getElementById('strokeOpacity').addEventListener('input', (e) => {
                    this.selectedElements.forEach(el => {
                        el.setAttribute('stroke-opacity', e.target.value);
                    });
                    document.getElementById('strokeOpacityValue').textContent = Math.round(e.target.value * 100) + '%';
                    this.saveState();
                });

                // Text properties
                document.getElementById('fontFamily').addEventListener('change', (e) => {
                    this.selectedElements.forEach(el => {
                        if (el.tagName === 'text') {
                            el.setAttribute('font-family', e.target.value);
                        }
                    });
                    this.saveState();
                });

                document.getElementById('fontSize').addEventListener('input', (e) => {
                    this.selectedElements.forEach(el => {
                        if (el.tagName === 'text') {
                            el.setAttribute('font-size', e.target.value);
                        }
                    });
                    this.saveState();
                });
            }

            updatePropertiesPanel() {
                if (this.selectedElements.length === 0) return;

                const el = this.selectedElements[0];
                
                // Update position
                if (el.tagName === 'text') {
                    document.getElementById('posX').value = el.getAttribute('x') || 0;
                    document.getElementById('posY').value = el.getAttribute('y') || 0;
                } else {
                    document.getElementById('posX').value = el.getAttribute('x') || 0;
                    document.getElementById('posY').value = el.getAttribute('y') || 0;
                }

                // Update size
                if (el.tagName === 'rect') {
                    document.getElementById('width').value = el.getAttribute('width') || 0;
                    document.getElementById('height').value = el.getAttribute('height') || 0;
                } else if (el.tagName === 'ellipse') {
                    document.getElementById('width').value = (el.getAttribute('rx') || 0) * 2;
                    document.getElementById('height').value = (el.getAttribute('ry') || 0) * 2;
                } else if (el.tagName === 'circle') {
                    document.getElementById('width').value = (el.getAttribute('r') || 0) * 2;
                    document.getElementById('height').value = (el.getAttribute('r') || 0) * 2;
                }

                // Update fill
                const fillColor = el.getAttribute('fill') || '#000000';
                const fillOpacity = el.getAttribute('fill-opacity') || 1;
                document.getElementById('fillColor').value = fillColor;
                document.getElementById('fillOpacity').value = fillOpacity;
                document.getElementById('fillOpacityValue').textContent = Math.round(fillOpacity * 100) + '%';

                // Update stroke
                const strokeColor = el.getAttribute('stroke') || '#000000';
                const strokeWidth = el.getAttribute('stroke-width') || 1;
                const strokeOpacity = el.getAttribute('stroke-opacity') || 1;
                document.getElementById('strokeColor').value = strokeColor;
                document.getElementById('strokeWidth').value = strokeWidth;
                document.getElementById('strokeOpacity').value = strokeOpacity;
                document.getElementById('strokeOpacityValue').textContent = Math.round(strokeOpacity * 100) + '%';

                // Update text properties
                if (el.tagName === 'text') {
                    document.getElementById('fontFamily').value = el.getAttribute('font-family') || 'Arial, sans-serif';
                    document.getElementById('fontSize').value = el.getAttribute('font-size') || '16';
                }

                this.updateColorPreviews();
            }

            updateColorPreviews() {
                document.getElementById('fillPreview').style.backgroundColor = document.getElementById('fillColor').value;
                document.getElementById('strokePreview').style.backgroundColor = document.getElementById('strokeColor').value;
            }

            updateCursorPosition(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = Math.round((e.clientX - rect.left) / this.zoom + this.panX);
                const y = Math.round((e.clientY - rect.top) / this.zoom + this.panY);
                document.getElementById('cursorPos').textContent = `${x}, ${y}`;
            }

            updateUI() {
                this.updateLayersList();
                this.updateUndoRedoButtons();
            }

            updateLayersList() {
                const layersList = document.getElementById('layersList');
                layersList.innerHTML = '';

                this.layers.forEach((layer, index) => {
                    const layerDiv = document.createElement('div');
                    layerDiv.className = `layer-item ${index === this.currentLayer ? 'selected' : ''}`;
                    layerDiv.innerHTML = `
                        <span>${layer.name}</span>
                        <div class="layer-controls">
                            <button class="layer-btn" onclick="editor.moveLayerUp(${index})" title="Move Up">‚Üë</button>
                            <button class="layer-btn" onclick="editor.moveLayerDown(${index})" title="Move Down">‚Üì</button>
                            <button class="layer-btn" onclick="editor.deleteLayer(${index})" title="Delete">√ó</button>
                        </div>
                    `;
                    layerDiv.onclick = () => this.setCurrentLayer(index);
                    layersList.appendChild(layerDiv);
                });
            }

            addLayer() {
                const layerName = `Layer ${this.layers.length + 1}`;
                const layer = {
                    id: Date.now(),
                    name: layerName,
                    visible: true,
                    locked: false
                };
                
                this.layers.push(layer);
                const layerGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                layerGroup.setAttribute('data-layer-id', layer.id);
                layerGroup.classList.add('layer-group');
                
                this.drawingLayers.appendChild(layerGroup);
                this.currentLayer = this.layers.length - 1;
                this.updateUI();
            }

            deleteLayer(index) {
                if (this.layers.length <= 1) return;
                
                const layer = this.layers[index];
                const layerGroup = this.drawingLayers.querySelector(`[data-layer-id="${layer.id}"]`);
                if (layerGroup) {
                    layerGroup.remove();
                }
                
                this.layers.splice(index, 1);
                if (this.currentLayer >= this.layers.length) {
                    this.currentLayer = this.layers.length - 1;
                }
                this.updateUI();
            }

            moveLayerUp(index) {
                if (index > 0) {
                    const temp = this.layers[index];
                    this.layers[index] = this.layers[index - 1];
                    this.layers[index - 1] = temp;
                    
                    const groups = this.drawingLayers.querySelectorAll('.layer-group');
                    const layerGroup = groups[index];
                    const prevLayerGroup = groups[index - 1];
                    
                    this.drawingLayers.insertBefore(layerGroup, prevLayerGroup);
                    this.updateUI();
                }
            }

            moveLayerDown(index) {
                if (index < this.layers.length - 1) {
                    const temp = this.layers[index];
                    this.layers[index] = this.layers[index + 1];
                    this.layers[index + 1] = temp;
                    
                    const groups = this.drawingLayers.querySelectorAll('.layer-group');
                    const layerGroup = groups[index];
                    const nextLayerGroup = groups[index + 1];
                    
                    this.drawingLayers.insertBefore(nextLayerGroup, layerGroup);
                    this.updateUI();
                }
            }

            setCurrentLayer(index) {
                this.currentLayer = index;
                this.updateUI();
            }

            toggleGrid() {
                this.showGrid = !this.showGrid;
                const gridRect = document.getElementById('gridRect');
                gridRect.style.display = this.showGrid ? 'block' : 'none';
            }

            toggleSnapToGrid() {
                this.snapToGrid = !this.snapToGrid;
                const btn = document.getElementById('snapToGridBtn');
                btn.classList.toggle('active', this.snapToGrid);
            }

            saveState() {
                const svgData = this.canvas.innerHTML;
                
                // Remove history after current index (for redo functionality)
                this.history = this.history.slice(0, this.historyIndex + 1);
                
                // Add current state
                this.history.push(svgData);
                this.historyIndex++;
                
                // Limit history size
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                    this.historyIndex--;
                }
                
                this.updateUndoRedoButtons();
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.canvas.innerHTML = this.history[this.historyIndex];
                    this.drawingLayers = document.getElementById('drawingLayers');
                    this.selectionOverlay = document.getElementById('selectionOverlay');
                    this.clearSelection();
                    this.updateUndoRedoButtons();
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.canvas.innerHTML = this.history[this.historyIndex];
                    this.drawingLayers = document.getElementById('drawingLayers');
                    this.selectionOverlay = document.getElementById('selectionOverlay');
                    this.clearSelection();
                    this.updateUndoRedoButtons();
                }
            }

            updateUndoRedoButtons() {
                document.getElementById('undoBtn').disabled = this.historyIndex <= 0;
                document.getElementById('redoBtn').disabled = this.historyIndex >= this.history.length - 1;
            }

            exportSVG() {
                const svgData = new XMLSerializer().serializeToString(this.canvas);
                const blob = new Blob([svgData], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'svg-editor-export.svg';
                a.click();
                
                URL.revokeObjectURL(url);
            }

            exportPNG() {
                try {
                    console.log('=== PNG Export Started ===');
                    this.updateStatus('Preparing PNG export...');
                    
                    // Add visual feedback - disable button temporarily
                    const exportBtn = document.getElementById('exportPngBtn');
                    if (exportBtn) {
                        exportBtn.disabled = true;
                        exportBtn.style.opacity = '0.5';
                    }
                    
                    // Calculate the bounding box of all content
                    console.log('Calculating content bounds...');
                    const contentBounds = this.getContentBounds();
                    console.log('Content bounds result:', contentBounds);
                    
                    if (!contentBounds) {
                        console.log('No content found for export');
                        this.updateStatus('No content to export - Create some shapes first');
                        alert('No content to export. Please create some shapes first.');
                        
                        // Re-enable button
                        if (exportBtn) {
                            exportBtn.disabled = false;
                            exportBtn.style.opacity = '1';
                        }
                        
                        // Reset status after delay
                        setTimeout(() => {
                            this.updateStatus('Ready');
                        }, 3000);
                        return;
                    }

                    console.log('Creating export SVG...');
                    // Create a clean SVG without viewBox transformations
                    const exportSvg = this.createCleanExportSVG(contentBounds);
                    console.log('Export SVG created:', exportSvg.substring(0, 200) + '...');
                    
                    // Set up canvas with proper dimensions and high DPI support
                    const pixelRatio = window.devicePixelRatio || 1;
                    const exportWidth = Math.max(contentBounds.width, 100);
                    const exportHeight = Math.max(contentBounds.height, 100);
                    
                    console.log('Export dimensions:', exportWidth, 'x', exportHeight, 'at', pixelRatio + 'x DPI');
                    
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set actual size in pixels for high DPI
                    canvas.width = exportWidth * pixelRatio;
                    canvas.height = exportHeight * pixelRatio;
                    
                    // Scale the canvas back down using CSS
                    canvas.style.width = exportWidth + 'px';
                    canvas.style.height = exportHeight + 'px';
                    
                    // Scale the drawing context so everything draws at high DPI
                    ctx.scale(pixelRatio, pixelRatio);
                    
                    // Set white background
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, exportWidth, exportHeight);
                    
                    this.updateStatus('Converting to PNG...');
                    
                    // Create and load the image
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        try {
                            console.log('Image loaded successfully, drawing to canvas...');
                            ctx.drawImage(img, 0, 0, exportWidth, exportHeight);
                            
                            this.updateStatus('Finalizing PNG file...');
                            
                            // Convert to blob and download
                            canvas.toBlob((blob) => {
                                if (blob) {
                                    console.log('PNG blob created successfully, size:', blob.size, 'bytes');
                                    const url = URL.createObjectURL(blob);
                                    const a = document.createElement('a');
                                    a.href = url;
                                    a.download = `svg-editor-export-${Date.now()}.png`;
                                    document.body.appendChild(a);
                                    a.click();
                                    document.body.removeChild(a);
                                    URL.revokeObjectURL(url);
                                    
                                    this.updateStatus('PNG exported successfully!');
                                    console.log('=== PNG Export Completed Successfully ===');
                                } else {
                                    throw new Error('Failed to create PNG blob');
                                }
                                
                                // Re-enable button
                                if (exportBtn) {
                                    exportBtn.disabled = false;
                                    exportBtn.style.opacity = '1';
                                }
                                
                                // Reset status after delay
                                setTimeout(() => {
                                    this.updateStatus('Ready');
                                }, 3000);
                                
                            }, 'image/png', 1.0);
                            
                        } catch (error) {
                            console.error('PNG export canvas error:', error);
                            this.updateStatus('PNG export failed');
                            alert('PNG export failed: ' + error.message);
                            
                            // Re-enable button
                            if (exportBtn) {
                                exportBtn.disabled = false;
                                exportBtn.style.opacity = '1';
                            }
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.error('Image load error:', error);
                        console.log('Trying fallback export method...');
                        this.updateStatus('Trying alternative export method...');
                        
                        // Try alternative method for problematic SVGs
                        setTimeout(() => {
                            this.exportPNGFallback(contentBounds);
                            
                            // Re-enable button
                            if (exportBtn) {
                                exportBtn.disabled = false;
                                exportBtn.style.opacity = '1';
                            }
                        }, 1000);
                    };
                    
                    // Convert SVG to data URL
                    console.log('Creating SVG blob...');
                    const svgBlob = new Blob([exportSvg], { type: 'image/svg+xml;charset=utf-8' });
                    const svgUrl = URL.createObjectURL(svgBlob);
                    console.log('SVG URL created, loading image...');
                    
                    // Set timeout for image loading
                    setTimeout(() => {
                        if (!img.complete) {
                            console.warn('Image load timeout after 10 seconds');
                            img.onerror(new Error('Image load timeout'));
                        }
                    }, 10000);
                    
                    img.src = svgUrl;
                    
                } catch (error) {
                    console.error('PNG export initialization error:', error);
                    this.updateStatus('PNG export failed');
                    alert('PNG export failed: ' + error.message);
                    
                    // Re-enable button
                    const exportBtn = document.getElementById('exportPngBtn');
                    if (exportBtn) {
                        exportBtn.disabled = false;
                        exportBtn.style.opacity = '1';
                    }
                }
            }

            // Fallback method for SVGs that can't be loaded as images
            exportPNGFallback(contentBounds) {
                try {
                    this.updateStatus('Using fallback PNG export method...');
                    
                    const pixelRatio = window.devicePixelRatio || 1;
                    const exportWidth = Math.max(contentBounds.width, 100);
                    const exportHeight = Math.max(contentBounds.height, 100);
                    
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = exportWidth * pixelRatio;
                    canvas.height = exportHeight * pixelRatio;
                    canvas.style.width = exportWidth + 'px';
                    canvas.style.height = exportHeight + 'px';
                    
                    ctx.scale(pixelRatio, pixelRatio);
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, exportWidth, exportHeight);
                    
                    // Draw shapes manually to canvas
                    this.drawShapesToCanvas(ctx, contentBounds);
                    
                    canvas.toBlob((blob) => {
                        if (blob) {
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `svg-editor-export-fallback-${Date.now()}.png`;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            this.updateStatus('PNG exported successfully (fallback method)');
                        } else {
                            this.updateStatus('PNG export failed - fallback method failed');
                            alert('PNG export failed: Unable to create image file');
                        }
                    }, 'image/png', 1.0);
                    
                } catch (error) {
                    console.error('PNG fallback export error:', error);
                    this.updateStatus('PNG export failed');
                    alert('PNG export failed: ' + error.message);
                }
            }

            // Get the bounding box of all content
            getContentBounds() {
                console.log('Getting content bounds...');
                const elements = this.drawingLayers.querySelectorAll('*:not(g)');
                console.log('Found', elements.length, 'elements for bounds calculation');
                
                if (elements.length === 0) {
                    console.log('No elements found, returning null');
                    return null;
                }

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                let validElements = 0;
                
                elements.forEach((el, index) => {
                    try {
                        console.log(`Processing element ${index}:`, el.tagName, el);
                        const bbox = el.getBBox();
                        console.log(`Element ${index} bbox:`, bbox);
                        
                        if (bbox.width > 0 && bbox.height > 0) {
                            minX = Math.min(minX, bbox.x);
                            minY = Math.min(minY, bbox.y);
                            maxX = Math.max(maxX, bbox.x + bbox.width);
                            maxY = Math.max(maxY, bbox.y + bbox.height);
                            validElements++;
                        }
                    } catch (e) {
                        console.log(`getBBox failed for element ${index}, trying attributes...`);
                        // If getBBox fails, try to get bounds from attributes
                        const x = parseFloat(el.getAttribute('x') || el.getAttribute('cx') || 0);
                        const y = parseFloat(el.getAttribute('y') || el.getAttribute('cy') || 0);
                        const width = parseFloat(el.getAttribute('width') || el.getAttribute('r') || 10);
                        const height = parseFloat(el.getAttribute('height') || el.getAttribute('r') || 10);
                        
                        console.log(`Element ${index} attributes: x=${x}, y=${y}, w=${width}, h=${height}`);
                        
                        if (width > 0 && height > 0) {
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x + width);
                            maxY = Math.max(maxY, y + height);
                            validElements++;
                        }
                    }
                });

                if (validElements === 0) {
                    console.log('No valid elements found, returning null');
                    return null;
                }

                // Add some padding
                const padding = 20;
                const bounds = {
                    x: minX - padding,
                    y: minY - padding,
                    width: (maxX - minX) + (padding * 2),
                    height: (maxY - minY) + (padding * 2)
                };
                
                console.log('Final content bounds:', bounds);
                return bounds;
            }

            // Create a clean SVG for export without viewBox transformations
            createCleanExportSVG(bounds) {
                const svgNamespace = 'http://www.w3.org/2000/svg';
                const exportSvg = document.createElementNS(svgNamespace, 'svg');
                
                exportSvg.setAttribute('width', bounds.width);
                exportSvg.setAttribute('height', bounds.height);
                exportSvg.setAttribute('viewBox', `${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`);
                exportSvg.setAttribute('xmlns', svgNamespace);
                
                // Clone all drawing layers
                const layersClone = this.drawingLayers.cloneNode(true);
                exportSvg.appendChild(layersClone);
                
                return new XMLSerializer().serializeToString(exportSvg);
            }

            // Draw shapes directly to canvas as fallback
            drawShapesToCanvas(ctx, bounds) {
                const elements = this.drawingLayers.querySelectorAll('*:not(g)');
                
                elements.forEach(el => {
                    ctx.save();
                    
                    try {
                        const x = (parseFloat(el.getAttribute('x') || el.getAttribute('cx') || 0) - bounds.x);
                        const y = (parseFloat(el.getAttribute('y') || el.getAttribute('cy') || 0) - bounds.y);
                        
                        // Set styles
                        const fill = el.getAttribute('fill') || '#000000';
                        const stroke = el.getAttribute('stroke') || 'none';
                        const strokeWidth = parseFloat(el.getAttribute('stroke-width') || 1);
                        
                        ctx.fillStyle = fill === 'none' ? 'transparent' : fill;
                        ctx.strokeStyle = stroke === 'none' ? 'transparent' : stroke;
                        ctx.lineWidth = strokeWidth;
                        
                        // Draw based on element type
                        switch (el.tagName.toLowerCase()) {
                            case 'rect':
                                const width = parseFloat(el.getAttribute('width') || 0);
                                const height = parseFloat(el.getAttribute('height') || 0);
                                if (fill !== 'none') ctx.fillRect(x, y, width, height);
                                if (stroke !== 'none') ctx.strokeRect(x, y, width, height);
                                break;
                                
                            case 'circle':
                                const r = parseFloat(el.getAttribute('r') || 0);
                                ctx.beginPath();
                                ctx.arc(x, y, r, 0, 2 * Math.PI);
                                if (fill !== 'none') ctx.fill();
                                if (stroke !== 'none') ctx.stroke();
                                break;
                                
                            case 'ellipse':
                                const rx = parseFloat(el.getAttribute('rx') || 0);
                                const ry = parseFloat(el.getAttribute('ry') || 0);
                                ctx.beginPath();
                                ctx.ellipse(x, y, rx, ry, 0, 0, 2 * Math.PI);
                                if (fill !== 'none') ctx.fill();
                                if (stroke !== 'none') ctx.stroke();
                                break;
                                
                            case 'line':
                                const x2 = parseFloat(el.getAttribute('x2') || 0) - bounds.x;
                                const y2 = parseFloat(el.getAttribute('y2') || 0) - bounds.y;
                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(x2, y2);
                                if (stroke !== 'none') ctx.stroke();
                                break;
                                
                            case 'text':
                                const fontSize = parseFloat(el.getAttribute('font-size') || 16);
                                const fontFamily = el.getAttribute('font-family') || 'Arial';
                                ctx.font = `${fontSize}px ${fontFamily}`;
                                ctx.textBaseline = 'top';
                                if (fill !== 'none') ctx.fillText(el.textContent || '', x, y);
                                if (stroke !== 'none') ctx.strokeText(el.textContent || '', x, y);
                                break;
                        }
                    } catch (error) {
                        console.warn('Error drawing element to canvas:', error, el);
                    }
                    
                    ctx.restore();
                });
            }

            openImportDialog() {
                const fileInput = document.getElementById('svgFileInput');
                fileInput.click();
            }

            handleSvgImport(event) {
                const file = event.target.files[0];
                if (!file) return;

                if (!file.type.includes('svg') && !file.name.toLowerCase().endsWith('.svg')) {
                    alert('Please select a valid SVG file.');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        this.importSVG(e.target.result);
                    } catch (error) {
                        console.error('Error importing SVG:', error);
                        alert('Error importing SVG file. Please check if the file is valid.');
                    }
                };
                reader.readAsText(file);
                
                // Clear the input so the same file can be selected again
                event.target.value = '';
            }

            importSVG(svgContent) {
                // Parse the SVG content
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
                const importedSvg = svgDoc.documentElement;

                // Check for parsing errors
                const parserError = svgDoc.querySelector('parsererror');
                if (parserError) {
                    throw new Error('Invalid SVG content');
                }

                // Create a new layer for the imported content
                const layerName = `Imported Layer ${this.layers.length + 1}`;
                const layer = {
                    id: Date.now(),
                    name: layerName,
                    visible: true,
                    locked: false
                };
                
                this.layers.push(layer);
                const layerGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                layerGroup.setAttribute('data-layer-id', layer.id);
                layerGroup.classList.add('layer-group');
                this.drawingLayers.appendChild(layerGroup);

                // Import all child elements from the SVG
                this.importSvgElements(importedSvg, layerGroup);

                // Update UI and save state
                this.currentLayer = this.layers.length - 1;
                this.updateUI();
                this.saveState();
                
                // Show success message
                this.updateStatus(`SVG imported successfully to ${layerName}`);
            }

            importSvgElements(sourceElement, targetGroup) {
                // Process all child elements of the imported SVG
                const children = Array.from(sourceElement.children);
                
                children.forEach(child => {
                    // Skip non-graphic elements like defs, metadata, etc.
                    if (this.isGraphicElement(child)) {
                        // Clone the element to avoid modifying the original
                        const clonedElement = child.cloneNode(true);
                        
                        // Add svg-element class for selection and styling
                        clonedElement.classList.add('svg-element');
                        
                        // Recursively import nested elements (like groups)
                        if (child.children && child.children.length > 0) {
                            this.importSvgElements(child, clonedElement);
                        }
                        
                        // Add to target layer group
                        targetGroup.appendChild(clonedElement);
                    }
                });
            }

            isGraphicElement(element) {
                // List of SVG elements that should be imported as drawable elements
                const graphicElements = [
                    'rect', 'circle', 'ellipse', 'line', 'polyline', 'polygon', 
                    'path', 'text', 'tspan', 'g', 'use', 'image'
                ];
                return graphicElements.includes(element.tagName.toLowerCase());
            }

            initKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Spacebar for panning mode
                    if (e.code === 'Space' && !this.spacebarPressed) {
                        this.spacebarPressed = true;
                        this.canvas.style.cursor = 'grab';
                        this.showNavigationIndicator();
                        this.updateStatus('Panning Mode - Click and drag to navigate');
                        e.preventDefault();
                        return;
                    }

                    // Arrow keys for panning
                    if (!e.ctrlKey && !e.metaKey && !e.shiftKey) {
                        const panStep = 20;
                        switch (e.key) {
                            case 'ArrowUp':
                                this.panY -= panStep;
                                this.updateCanvasSize();
                                e.preventDefault();
                                return;
                            case 'ArrowDown':
                                this.panY += panStep;
                                this.updateCanvasSize();
                                e.preventDefault();
                                return;
                            case 'ArrowLeft':
                                this.panX -= panStep;
                                this.updateCanvasSize();
                                e.preventDefault();
                                return;
                            case 'ArrowRight':
                                this.panX += panStep;
                                this.updateCanvasSize();
                                e.preventDefault();
                                return;
                        }
                    }

                    // Tool shortcuts
                    if (!e.ctrlKey && !e.metaKey) {
                        switch (e.key.toLowerCase()) {
                            case 'v': this.setTool('select'); break;
                            case 'p': this.setTool('pen'); break;
                            case 'r': this.setTool('rectangle'); break;
                            case 'c': this.setTool('circle'); break;
                            case 'e': this.setTool('ellipse'); break;
                            case 'l': this.setTool('line'); break;
                            case 'a': this.setTool('arrow'); break;
                            case 't': this.setTool('text'); break;
                            case 'g': this.toggleGrid(); break;
                            case 's': this.toggleSnapToGrid(); break;
                            case 'delete':
                            case 'backspace':
                                this.deleteSelected();
                                break;
                            case 'escape':
                                // Check if help is open first
                                if (document.getElementById('helpOverlay').style.display === 'flex') {
                                    this.hideHelp();
                                } else {
                                    this.clearSelection();
                                }
                                e.preventDefault();
                                break;
                            case '?':
                            case '/':
                                this.showHelp();
                                e.preventDefault();
                                break;
                        }
                    }
                    
                    // Undo/Redo
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        this.undo();
                    } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                        e.preventDefault();
                        this.redo();
                    }
                    
                    // Copy/Paste
                    if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                        e.preventDefault();
                        this.copySelected();
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                        e.preventDefault();
                        this.paste();
                    }
                    
                    // Zoom shortcuts
                    if (e.key === '+' || e.key === '=') {
                        e.preventDefault();
                        this.zoomIn();
                    } else if (e.key === '-') {
                        e.preventDefault();
                        this.zoomOut();
                    } else if (e.key === '0') {
                        e.preventDefault();
                        this.setZoom(1);
                    }
                });

                // Handle spacebar release for panning mode
                document.addEventListener('keyup', (e) => {
                    if (e.code === 'Space' && this.spacebarPressed) {
                        this.spacebarPressed = false;
                        this.canvas.style.cursor = this.getCursorForTool(this.currentTool);
                        this.hideNavigationIndicator();
                        this.updateStatus(`Tool: ${this.currentTool.charAt(0).toUpperCase() + this.currentTool.slice(1)}`);
                        e.preventDefault();
                    }
                });
            }

            deleteSelected() {
                this.selectedElements.forEach(el => el.remove());
                this.clearSelection();
                this.saveState();
            }

            copySelected() {
                if (this.selectedElements.length > 0) {
                    this.clipboard = this.selectedElements.map(el => el.cloneNode(true));
                }
            }

            paste() {
                if (this.clipboard) {
                    this.clipboard.forEach(el => {
                        const clone = el.cloneNode(true);
                        clone.setAttribute('x', parseFloat(clone.getAttribute('x')) + 20);
                        clone.setAttribute('y', parseFloat(clone.getAttribute('y')) + 20);
                        this.drawingLayers.appendChild(clone);
                    });
                    this.saveState();
                }
            }

            updateStatus(message) {
                console.log('Status update:', message); // Debug logging
                const statusElement = document.getElementById('statusText');
                if (statusElement) {
                    statusElement.textContent = message;
                } else {
                    console.error('Status element not found');
                }
            }

            startPan(clientX, clientY) {
                this.isPanning = true;
                this.panStart = { x: clientX, y: clientY };
                this.canvas.style.cursor = 'grabbing';
            }

            updatePan(clientX, clientY) {
                if (!this.isPanning) return;
                
                const dx = (clientX - this.panStart.x) / this.zoom;
                const dy = (clientY - this.panStart.y) / this.zoom;
                
                this.panX -= dx;
                this.panY -= dy;
                
                this.panStart = { x: clientX, y: clientY };
                this.updateCanvasSize();
            }

            endPan() {
                this.isPanning = false;
                // If spacebar is still pressed, keep grab cursor, otherwise use tool cursor
                this.canvas.style.cursor = this.spacebarPressed ? 'grab' : this.getCursorForTool(this.currentTool);
            }

            startTouchZoom(e) {
                if (e.touches.length !== 2) return;
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                this.startDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                this.startZoom = this.zoom;
            }

            updateTouchZoom(e) {
                if (e.touches.length !== 2) return;
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                const distance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                
                const scale = distance / this.startDistance;
                this.setZoom(Math.max(0.1, Math.min(5, this.startZoom * scale)));
            }

            endTouchZoom() {
                this.startDistance = 0;
                this.startZoom = 0;
            }

            // Help system methods
            showHelp() {
                document.getElementById('helpOverlay').style.display = 'flex';
            }

            hideHelp() {
                document.getElementById('helpOverlay').style.display = 'none';
            }

            // Navigation indicator methods
            showNavigationIndicator() {
                const indicator = document.getElementById('navigationIndicator');
                indicator.style.display = 'block';
            }

            hideNavigationIndicator() {
                const indicator = document.getElementById('navigationIndicator');
                indicator.style.display = 'none';
            }
        }

        // Initialize the editor
        const editor = new SVGEditor();

        // Undo/Redo button events
        document.getElementById('undoBtn').addEventListener('click', () => editor.undo());
        document.getElementById('redoBtn').addEventListener('click', () => editor.redo());
    </script>

<script>
/**
 * Iframe ÂÖÉÁ¥†È´ò‰∫ÆÊ≥®ÂÖ•ËÑöÊú¨
 * ÈúÄË¶ÅÂú®ÁõÆÊ†áÁΩëÁ´ô‰∏≠ÂºïÂÖ•Ê≠§ËÑöÊú¨Êù•ÊîØÊåÅË∑®Âüü iframe È´ò‰∫ÆÂäüËÉΩ
 *
 * ‰ΩøÁî®ÊñπÊ≥ïÔºö
 * 1. Â∞ÜÊ≠§ËÑöÊú¨Ê∑ªÂä†Âà∞ÁõÆÊ†áÁΩëÁ´ôÁöÑ HTML ‰∏≠
 * 2. ÊàñÈÄöËøáÊµèËßàÂô®Êâ©Â±ï„ÄÅÁî®Êà∑ËÑöÊú¨Á≠âÊñπÂºèÊ≥®ÂÖ•
 */

(function () {
  "use strict";

  // Ê£ÄÊü•ÊòØÂê¶Âú® iframe ‰∏≠
  if (window.self === window.top) {
    return; // ‰∏çÂú® iframe ‰∏≠Ôºå‰∏çÊâßË°å
  }

  // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂàùÂßãÂåñËøá
  if (window.__iframeHighlightInitialized) {
    return;
  }
  window.__iframeHighlightInitialized = true;
  console.log("Iframe È´ò‰∫ÆËÑöÊú¨Â∑≤Âä†ËΩΩ");

  // ÂàõÂª∫È´ò‰∫ÆË¶ÜÁõñÂ±Ç
  var overlay = document.createElement("div");
  overlay.id = "iframe-highlight-overlay";
  overlay.style.cssText = "\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n    pointer-events: none;\n    z-index: 999999;\n    overflow: hidden;\n  ";

  // ÂàõÂª∫ÊÇ¨ÂÅúÈ´ò‰∫ÆÊ°ÜÔºàËôöÁ∫øËæπÊ°ÜÔºâ
  var highlightBox = document.createElement("div");
  highlightBox.id = "iframe-highlight-box";
  highlightBox.style.cssText = "\n    position: absolute;\n    border: 2px dashed #007AFF;\n    background: rgba(0, 122, 255, 0.08);\n    pointer-events: none;\n    display: none;\n    transition: all 0.1s ease;\n    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.8);\n    border-radius: 2px;\n  ";

  // ÂàõÂª∫ÈÄâ‰∏≠ËäÇÁÇπÁöÑÂ∏∏È©ªÈ´ò‰∫ÆÊ°ÜÔºàÂÆûÁ∫øËæπÊ°ÜÔºâ
  var selectedBox = document.createElement("div");
  selectedBox.id = "iframe-selected-box";
  selectedBox.style.cssText = "\n    position: absolute;\n    border: 2px solid #007AFF;\n    pointer-events: none;\n    display: none;\n    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.9), 0 0 8px rgba(255, 107, 53, 0.4);\n    border-radius: 2px;\n    z-index: 1000000;\n  ";

  // ÂàõÂª∫ÊÇ¨ÂÅúÊ†áÁ≠æÊòæÁ§∫
  var tagLabel = document.createElement("div");
  tagLabel.id = "iframe-tag-label";
  tagLabel.style.cssText = "\n    position: absolute;\n    background: #007AFF;\n    color: white;\n    padding: 2px 6px;\n    font-size: 11px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    border-radius: 2px;\n    pointer-events: none;\n    display: none;\n    white-space: nowrap;\n    z-index: 1000001;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    font-weight: 500;\n  ";

  // ÂàõÂª∫ÈÄâ‰∏≠ËäÇÁÇπÊ†áÁ≠æ
  var selectedLabel = document.createElement("div");
  selectedLabel.id = "iframe-selected-label";
  selectedLabel.style.cssText = "\n    position: absolute;\n    background: #007AFF;\n    color: white;\n    padding: 3px 8px;\n    font-size: 11px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    border-radius: 3px;\n    pointer-events: none;\n    display: none;\n    white-space: nowrap;\n    z-index: 1000002;\n    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);\n    font-weight: 600;\n  ";
  overlay.appendChild(highlightBox);
  overlay.appendChild(selectedBox);
  overlay.appendChild(tagLabel);
  overlay.appendChild(selectedLabel);
  document.body.appendChild(overlay);

  // Â≠òÂÇ®ÂΩìÂâçÈÄâ‰∏≠ÁöÑÂÖÉÁ¥†
  var selectedElement = null;
  var highlightEnabled = false;

  // Êõ¥Êñ∞ÈÄâ‰∏≠ÂÖÉÁ¥†ÁöÑÈ´ò‰∫ÆÊòæÁ§∫
  function updateSelectedHighlight(element) {
    console.log("updateSelectedHighlight called with:", element);
    if (!element) {
      selectedBox.style.display = "none";
      selectedLabel.style.display = "none";
      selectedElement = null;
      console.log("Cleared selected highlight");
      return;
    }
    selectedElement = element;
    var rect = element.getBoundingClientRect();
    console.log("Selected element rect:", rect);

    // Êõ¥Êñ∞ÈÄâ‰∏≠È´ò‰∫ÆÊ°Ü‰ΩçÁΩÆ
    selectedBox.style.display = "block";
    selectedBox.style.left = "".concat(rect.left - 2, "px");
    selectedBox.style.top = "".concat(rect.top - 2, "px");
    selectedBox.style.width = "".concat(rect.width + 4, "px");
    selectedBox.style.height = "".concat(rect.height + 4, "px");

    // Êõ¥Êñ∞ÈÄâ‰∏≠Ê†áÁ≠æ‰ΩçÁΩÆÂíåÂÜÖÂÆπ
    selectedLabel.style.display = "block";
    selectedLabel.textContent = "\u2713 <".concat(element.tagName.toLowerCase(), ">");

    // ËÆ°ÁÆóÊ†áÁ≠æ‰ΩçÁΩÆÔºåÁ°Æ‰øù‰∏çË∂ÖÂá∫ËßÜÁ™ó
    var labelTop = rect.top - 28;
    var labelLeft = rect.left;

    // Â¶ÇÊûúÊ†áÁ≠æ‰ºöË∂ÖÂá∫È°∂ÈÉ®ÔºåÊòæÁ§∫Âú®ÂÖÉÁ¥†‰∏ãÊñπ
    if (labelTop < 5) {
      labelTop = rect.bottom + 5;
    }

    // Â¶ÇÊûúÊ†áÁ≠æ‰ºöË∂ÖÂá∫Âè≥‰æßÔºåÂêëÂ∑¶Ë∞ÉÊï¥
    var labelWidth = selectedLabel.offsetWidth || 100; // È¢Ñ‰º∞ÂÆΩÂ∫¶
    if (labelLeft + labelWidth > window.innerWidth - 10) {
      labelLeft = window.innerWidth - labelWidth - 10;
    }
    selectedLabel.style.left = "".concat(Math.max(5, labelLeft), "px");
    selectedLabel.style.top = "".concat(labelTop, "px");
    console.log("Selected highlight positioned at:", {
      left: selectedBox.style.left,
      top: selectedBox.style.top,
      width: selectedBox.style.width,
      height: selectedBox.style.height
    });
  }
  function getElementSelector(element) {
    if (!(element instanceof Element)) throw new Error('Argument must be a DOM element');
    var segments = [];
    var current = element;
    while (current !== document.documentElement) {
      var selector = '';
      // ‰ºòÂÖàÊ£ÄÊü•ÂîØ‰∏ÄID
      if (current.id && document.querySelectorAll("#".concat(current.id)).length === 1) {
        segments.unshift("#".concat(current.id));
        break; // IDÂîØ‰∏ÄÔºåÊó†ÈúÄÁªßÁª≠Âêë‰∏ä
      }

      // ÁîüÊàêÁ±ªÂêçÈÄâÊã©Âô®ÔºàÂèñÁ¨¨‰∏Ä‰∏™ÊúâÊïàÁ±ªÂêçÔºâ
      var classes = Array.from(current.classList).filter(function (c) {
        return !c.startsWith('js-');
      });
      var className = classes.length > 0 ? ".".concat(classes[0]) : '';

      // ÁîüÊàê‰ΩçÁΩÆÁ¥¢ÂºïÔºànth-childÔºâ
      var tag = current.tagName.toLowerCase();
      if (!className) {
        var siblings = Array.from(current.parentNode.children);
        var index = siblings.findIndex(function (el) {
          return el === current;
        }) + 1;
        selector = "".concat(tag, ":nth-child(").concat(index, ")");
      } else {
        selector = className;
      }
      segments.unshift(selector);
      current = current.parentElement;
    }

    // Â§ÑÁêÜÊ†πÂÖÉÁ¥†
    if (current === document.documentElement) {
      segments.unshift('html');
    }
    return segments.join(' > ');
  }

  // Ëé∑ÂèñÂÖÉÁ¥†ÊñáÊú¨ÂÜÖÂÆπ
  function getElementText(element) {
    var _element$textContent;
    if (element.tagName === "INPUT") {
      return element.value || element.placeholder || "";
    }
    if (element.tagName === "TEXTAREA") {
      return element.value || element.placeholder || "";
    }
    var text = ((_element$textContent = element.textContent) === null || _element$textContent === void 0 ? void 0 : _element$textContent.trim()) || "";
    return text.length > 50 ? text.substring(0, 50) + "..." : text;
  }

  // Ëé∑ÂèñÂÖÉÁ¥†Â±ûÊÄß‰ø°ÊÅØ
  function getElementAttributes(element) {
    var attrs = {};
    for (var i = 0; i < element.attributes.length; i++) {
      var attr = element.attributes[i];
      attrs[attr.name] = attr.value;
    }
    return attrs;
  }

  // Èº†Ê†áÊÇ¨ÂÅú‰∫ã‰ª∂Â§ÑÁêÜ
  function handleMouseOver(e) {
    if (!highlightEnabled) return;
    var target = e.target;
    if (!target || target === overlay || target === highlightBox || target === tagLabel || target === selectedBox || target === selectedLabel) {
      return;
    }

    // ÈÅøÂÖçÈ´ò‰∫Æ html Âíå body ÂÖÉÁ¥†
    if (target === document.documentElement || target === document.body) {
      return;
    }

    // Â¶ÇÊûúÊòØÂ∑≤ÈÄâ‰∏≠ÁöÑÂÖÉÁ¥†Ôºå‰∏çÊòæÁ§∫ÊÇ¨ÂÅúÈ´ò‰∫Æ
    if (target === selectedElement) {
      highlightBox.style.display = "none";
      tagLabel.style.display = "none";
      return;
    }
    var rect = target.getBoundingClientRect();
    var selector = getElementSelector(target);
    var text = getElementText(target);
    var attributes = getElementAttributes(target);

    // Êõ¥Êñ∞ÊÇ¨ÂÅúÈ´ò‰∫ÆÊ°Ü‰ΩçÁΩÆ
    highlightBox.style.display = "block";
    highlightBox.style.left = "".concat(rect.left - 2, "px");
    highlightBox.style.top = "".concat(rect.top - 2, "px");
    highlightBox.style.width = "".concat(rect.width + 4, "px");
    highlightBox.style.height = "".concat(rect.height + 4, "px");

    // Êõ¥Êñ∞Ê†áÁ≠æ‰ΩçÁΩÆÂíåÂÜÖÂÆπ
    tagLabel.style.display = "block";
    tagLabel.textContent = "<".concat(target.tagName.toLowerCase(), ">");

    // ËÆ°ÁÆóÊ†áÁ≠æ‰ΩçÁΩÆÔºåÁ°Æ‰øù‰∏çË∂ÖÂá∫ËßÜÁ™ó
    var labelTop = rect.top - 22;
    var labelLeft = rect.left;

    // Â¶ÇÊûúÊ†áÁ≠æ‰ºöË∂ÖÂá∫È°∂ÈÉ®ÔºåÊòæÁ§∫Âú®ÂÖÉÁ¥†‰∏ãÊñπ
    if (labelTop < 0) {
      labelTop = rect.bottom + 5;
    }

    // Â¶ÇÊûúÊ†áÁ≠æ‰ºöË∂ÖÂá∫Âè≥‰æßÔºåÂêëÂ∑¶Ë∞ÉÊï¥
    if (labelLeft + tagLabel.offsetWidth > window.innerWidth) {
      labelLeft = window.innerWidth - tagLabel.offsetWidth - 5;
    }
    tagLabel.style.left = "".concat(Math.max(0, labelLeft), "px");
    tagLabel.style.top = "".concat(labelTop, "px");

    // ÂèëÈÄÅÊ∂àÊÅØÂà∞Áà∂Á™óÂè£
    var elementInfo = {
      tagName: target.tagName.toLowerCase(),
      rect: {
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
      },
      selector: selector,
      text: text,
      attributes: attributes,
      url: window.location.href,
      path: window.location.pathname,
      timestamp: Date.now()
    };
    try {
      window.parent.postMessage({
        type: "iframe-element-hover",
        data: elementInfo,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("Êó†Ê≥ïÂèëÈÄÅÊ∂àÊÅØÂà∞Áà∂Á™óÂè£:", error);
    }
  }

  // Èº†Ê†áÁ¶ªÂºÄ‰∫ã‰ª∂Â§ÑÁêÜ
  function handleMouseOut(e) {
    if (!highlightEnabled) return;
    var relatedTarget = e.relatedTarget;

    // Â¶ÇÊûúÈº†Ê†áÁßªÂä®Âà∞È´ò‰∫ÆÁõ∏ÂÖ≥ÂÖÉÁ¥†‰∏äÔºå‰∏çÈöêËóèÈ´ò‰∫Æ
    if (relatedTarget && (relatedTarget === highlightBox || relatedTarget === tagLabel || relatedTarget === overlay || relatedTarget === selectedBox || relatedTarget === selectedLabel)) {
      return;
    }
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    try {
      window.parent.postMessage({
        type: "iframe-element-hover",
        data: null,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("Êó†Ê≥ïÂèëÈÄÅÊ∂àÊÅØÂà∞Áà∂Á™óÂè£:", error);
    }
  }

  // ÁÇπÂáª‰∫ã‰ª∂Â§ÑÁêÜ
  function handleClick(e) {
    var target = e.target;
    if (!target || target === overlay || target === highlightBox || target === tagLabel || target === selectedBox || target === selectedLabel) {
      return;
    }

    // ÈÅøÂÖçÂ§ÑÁêÜ html Âíå body ÂÖÉÁ¥†
    if (target === document.documentElement || target === document.body) {
      return;
    }

    // Ê£ÄÊü•ÊòØÂê¶ÊòØ‰∫§‰∫íÂÖÉÁ¥†ÔºåËøô‰∫õÂÖÉÁ¥†ÈúÄË¶Å‰øùÁïôÈªòËÆ§Ë°å‰∏∫
    var isInteractiveElement = ['input', 'textarea', 'select', 'button', 'a'].includes(target.tagName.toLowerCase());

    // Â¶ÇÊûúÈ´ò‰∫ÆÂäüËÉΩÂêØÁî®ÔºåÂØπ‰∫éÈùû‰∫§‰∫íÂÖÉÁ¥†ÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫Âíå‰∫ã‰ª∂‰º†Êí≠
    if (highlightEnabled) {
      e.preventDefault();
      e.stopPropagation();
    }
    var rect = target.getBoundingClientRect();
    var selector = getElementSelector(target);
    var text = getElementText(target);
    var attributes = getElementAttributes(target);
    console.log("Element clicked:", {
      tagName: target.tagName,
      selector: selector,
      rect: rect
    });

    // Á´ãÂç≥Êõ¥Êñ∞ÈÄâ‰∏≠È´ò‰∫Æ
    updateSelectedHighlight(target);

    // ÈöêËóèÊÇ¨ÂÅúÈ´ò‰∫ÆÔºåÂõ†‰∏∫Áé∞Âú®ÊòØÈÄâ‰∏≠Áä∂ÊÄÅ
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    var elementInfo = {
      tagName: target.tagName.toLowerCase(),
      rect: {
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
      },
      selector: selector,
      text: text,
      attributes: attributes,
      url: window.location.href,
      path: window.location.pathname,
      timestamp: Date.now()
    };
    try {
      window.parent.postMessage({
        type: "iframe-element-click",
        data: elementInfo,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("Êó†Ê≥ïÂèëÈÄÅÊ∂àÊÅØÂà∞Áà∂Á™óÂè£:", error);
    }
  }

  // ÁõëÂê¨Êù•Ëá™Áà∂Á™óÂè£ÁöÑÊ∂àÊÅØ
  function handleParentMessage(event) {
    console.log("Received message from parent:", event.data);
    if (event.data.type === "iframe-highlight-toggle") {
      var enabled = event.data.enabled;
      console.log("Highlight toggle:", enabled);
      if (enabled) {
        enableHighlight();
      } else {
        disableHighlight();
      }
    } else if (event.data.type === "enable-iframe-highlight") {
      console.log("Enable iframe highlight");
      enableHighlight();
    } else if (event.data.type === "disable-iframe-highlight") {
      console.log("Disable iframe highlight");
      disableHighlight();
    } else if (event.data.type === "toggle-iframe-highlight") {
      var _enabled = event.data.enabled !== undefined ? event.data.enabled : !highlightEnabled;
      console.log("Toggle iframe highlight to:", _enabled);
      if (_enabled) {
        enableHighlight();
      } else {
        disableHighlight();
      }
    } else if (event.data.type === "update-selected-element") {
      var selector = event.data.selector;
      console.log("Update selected element with selector:", selector);
      if (selector) {
        try {
          var element = document.querySelector(selector);
          console.log("Found element by selector:", element);
          updateSelectedHighlight(element);
        } catch (error) {
          console.warn("Failed to select element:", error);
          updateSelectedHighlight(null);
        }
      } else {
        updateSelectedHighlight(null);
      }
    } else if (event.data.type === "clear-selected-element") {
      console.log("Clear selected element");
      updateSelectedHighlight(null);
    }
  }

  // ÂêØÁî®È´ò‰∫ÆÂäüËÉΩ
  function enableHighlight() {
    console.log("Enabling highlight");
    document.addEventListener("mouseover", handleMouseOver, true);
    document.addEventListener("mouseout", handleMouseOut, true);
    document.addEventListener("click", handleClick, true);
    highlightEnabled = true;
    overlay.style.display = "block";
  }

  // Á¶ÅÁî®È´ò‰∫ÆÂäüËÉΩ
  function disableHighlight() {
    console.log("Disabling highlight");
    highlightEnabled = false;
    // ‰øùÊåÅ‰∫ã‰ª∂ÁõëÂê¨Âô®Ôºå‰ΩÜÈÄöËøá highlightEnabled ÂèòÈáèÊéßÂà∂Ë°å‰∏∫
    // ËøôÊ†∑ÂèØ‰ª•‰øùÁïôÈÄâ‰∏≠Áä∂ÊÄÅÁöÑÊòæÁ§∫
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    // ‰∏çÈöêËóè selectedBox Âíå selectedLabelÔºå‰øùÁïôÈÄâ‰∏≠Áä∂ÊÄÅ
  }

  // ÂÆåÂÖ®Á¶ÅÁî®È´ò‰∫ÆÂäüËÉΩÔºàÁßªÈô§ÊâÄÊúâÁõëÂê¨Âô®Ôºâ
  function fullyDisableHighlight() {
    console.log("Fully disabling highlight");
    highlightEnabled = false;
    document.removeEventListener("mouseover", handleMouseOver, true);
    document.removeEventListener("mouseout", handleMouseOut, true);
    document.removeEventListener("click", handleClick, true);
    overlay.style.display = "none";
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    selectedBox.style.display = "none";
    selectedLabel.style.display = "none";
  }

  // Ê∑ªÂä†‰∫ã‰ª∂ÁõëÂê¨
  enableHighlight();
  window.addEventListener("message", handleParentMessage);

  // Êö¥Èú≤ÂÖ®Â±ÄÂáΩÊï∞‰æõÂ§ñÈÉ®Ë∞ÉÁî®
  window.__iframeHighlightControl = {
    enable: enableHighlight,
    disable: disableHighlight,
    fullyDisable: fullyDisableHighlight,
    isEnabled: function isEnabled() {
      return highlightEnabled;
    },
    getSelectedElement: function getSelectedElement() {
      return selectedElement;
    },
    updateSelected: updateSelectedHighlight,
    // ÈÄöËøáÊ∂àÊÅØÂèëÈÄÅÂºÄÂÖ≥ÊéßÂà∂
    sendToggleMessage: function sendToggleMessage(enabled) {
      window.parent.postMessage({
        type: 'iframe-highlight-status',
        enabled: enabled || highlightEnabled,
        source: 'iframe-highlight-injector'
      }, '*');
    }
  };

  // ÈÄöÁü•Áà∂Á™óÂè£ËÑöÊú¨Â∑≤Âä†ËΩΩ
  try {
    window.parent.postMessage({
      type: "iframe-highlight-ready",
      data: {
        url: window.location.href,
        userAgent: navigator.userAgent,
        timestamp: Date.now()
      },
      source: "iframe-highlight-injector"
    }, "*");
  } catch (error) {
    console.warn("Êó†Ê≥ïÂèëÈÄÅÂ∞±Áª™Ê∂àÊÅØÂà∞Áà∂Á™óÂè£:", error);
  }

  // Ê∏ÖÁêÜÂáΩÊï∞
  window.__iframeHighlightCleanup = function () {
    fullyDisableHighlight();
    window.removeEventListener("message", handleParentMessage);
    if (overlay.parentElement) {
      overlay.parentElement.removeChild(overlay);
    }
    delete window.__iframeHighlightInitialized;
    delete window.__iframeHighlightCleanup;
  };
})();
</script>
</body>
</html>